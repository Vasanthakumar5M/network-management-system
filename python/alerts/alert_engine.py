"""
Alert Engine.

Central alert processing system that:
- Monitors traffic for keyword matches
- Detects concerning patterns
- Generates and stores alerts
- Triggers notifications
"""

import json
import threading
import time
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from pathlib import Path
from typing import Any, Callable, Dict, List, Optional, Set
from queue import Queue

from .keywords import (
    AlertCategory,
    AlertSeverity,
    Keyword,
    KeywordMatch,
    KeywordMatcher,
)


@dataclass
class Alert:
    """An alert generated by the system."""
    id: str
    timestamp: str
    severity: AlertSeverity
    category: AlertCategory
    title: str
    description: str
    
    # Source information
    source_ip: Optional[str] = None
    source_device: Optional[str] = None
    domain: Optional[str] = None
    url: Optional[str] = None
    
    # Match details
    matched_keyword: Optional[str] = None
    matched_text: Optional[str] = None
    context: Optional[str] = None
    
    # Status
    acknowledged: bool = False
    acknowledged_at: Optional[str] = None
    notes: str = ""
    
    # Metadata
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    def to_dict(self) -> dict:
        """Convert to dictionary."""
        return {
            "id": self.id,
            "timestamp": self.timestamp,
            "severity": self.severity.value,
            "category": self.category.value,
            "title": self.title,
            "description": self.description,
            "source_ip": self.source_ip,
            "source_device": self.source_device,
            "domain": self.domain,
            "url": self.url,
            "matched_keyword": self.matched_keyword,
            "matched_text": self.matched_text,
            "context": self.context,
            "acknowledged": self.acknowledged,
            "acknowledged_at": self.acknowledged_at,
            "notes": self.notes,
            "metadata": self.metadata
        }
    
    @classmethod
    def from_dict(cls, data: dict) -> "Alert":
        """Create from dictionary."""
        return cls(
            id=data["id"],
            timestamp=data["timestamp"],
            severity=AlertSeverity(data["severity"]),
            category=AlertCategory(data["category"]),
            title=data["title"],
            description=data["description"],
            source_ip=data.get("source_ip"),
            source_device=data.get("source_device"),
            domain=data.get("domain"),
            url=data.get("url"),
            matched_keyword=data.get("matched_keyword"),
            matched_text=data.get("matched_text"),
            context=data.get("context"),
            acknowledged=data.get("acknowledged", False),
            acknowledged_at=data.get("acknowledged_at"),
            notes=data.get("notes", ""),
            metadata=data.get("metadata", {})
        )


@dataclass
class AlertRule:
    """A rule for generating alerts."""
    id: str
    name: str
    enabled: bool = True
    
    # Conditions
    keywords: List[str] = field(default_factory=list)  # Keyword IDs
    categories: List[AlertCategory] = field(default_factory=list)
    domains: List[str] = field(default_factory=list)
    min_severity: AlertSeverity = AlertSeverity.LOW
    
    # Actions
    notify: bool = True
    block: bool = False
    log: bool = True
    
    # Rate limiting
    cooldown_seconds: int = 60  # Don't alert for same match within this time
    max_alerts_per_hour: int = 100
    
    # Internal tracking
    _last_alerts: Dict[str, datetime] = field(default_factory=dict)
    _hourly_count: int = 0
    _hour_start: Optional[datetime] = None


class AlertEngine:
    """
    Central alert processing engine.
    
    Processes traffic data, matches keywords, and generates alerts.
    """
    
    def __init__(
        self,
        config_file: Optional[str] = None,
        alerts_file: Optional[str] = None
    ):
        """
        Initialize the alert engine.
        
        Args:
            config_file: Path to alert configuration
            alerts_file: Path to store alerts
        """
        if config_file is None:
            project_root = Path(__file__).parent.parent.parent
            config_file = project_root / "config" / "alerts.json"
        
        if alerts_file is None:
            project_root = Path(__file__).parent.parent.parent
            alerts_file = project_root / "database" / "alerts.json"
        
        self.config_file = Path(config_file)
        self.alerts_file = Path(alerts_file)
        
        self.keyword_matcher = KeywordMatcher()
        self.rules: Dict[str, AlertRule] = {}
        self.alerts: List[Alert] = []
        
        # Callbacks for real-time notifications
        self._alert_callbacks: List[Callable[[Alert], None]] = []
        
        # Alert queue for async processing
        self.alert_queue: Queue = Queue()
        self._processing = False
        self._processor_thread: Optional[threading.Thread] = None
        
        # Rate limiting
        self._alert_counter: Dict[str, int] = {}
        self._counter_reset: Optional[datetime] = None
        
        self._load_config()
        self._load_alerts()
    
    def _load_config(self):
        """Load alert configuration."""
        if not self.config_file.exists():
            return
        
        try:
            data = json.loads(self.config_file.read_text())
            for rule_data in data.get("rules", []):
                rule = AlertRule(
                    id=rule_data["id"],
                    name=rule_data["name"],
                    enabled=rule_data.get("enabled", True),
                    keywords=rule_data.get("keywords", []),
                    categories=[AlertCategory(c) for c in rule_data.get("categories", [])],
                    domains=rule_data.get("domains", []),
                    min_severity=AlertSeverity(rule_data.get("min_severity", "low")),
                    notify=rule_data.get("notify", True),
                    block=rule_data.get("block", False),
                    log=rule_data.get("log", True),
                    cooldown_seconds=rule_data.get("cooldown_seconds", 60),
                    max_alerts_per_hour=rule_data.get("max_alerts_per_hour", 100)
                )
                self.rules[rule.id] = rule
        except Exception as e:
            print(json.dumps({"error": f"Failed to load alert config: {e}"}))
    
    def _save_config(self):
        """Save alert configuration."""
        self.config_file.parent.mkdir(parents=True, exist_ok=True)
        data = {
            "rules": [
                {
                    "id": rule.id,
                    "name": rule.name,
                    "enabled": rule.enabled,
                    "keywords": rule.keywords,
                    "categories": [c.value for c in rule.categories],
                    "domains": rule.domains,
                    "min_severity": rule.min_severity.value,
                    "notify": rule.notify,
                    "block": rule.block,
                    "log": rule.log,
                    "cooldown_seconds": rule.cooldown_seconds,
                    "max_alerts_per_hour": rule.max_alerts_per_hour
                }
                for rule in self.rules.values()
            ]
        }
        self.config_file.write_text(json.dumps(data, indent=2))
    
    def _load_alerts(self):
        """Load stored alerts."""
        if not self.alerts_file.exists():
            return
        
        try:
            data = json.loads(self.alerts_file.read_text())
            for alert_data in data.get("alerts", []):
                alert = Alert.from_dict(alert_data)
                self.alerts.append(alert)
        except Exception as e:
            print(json.dumps({"error": f"Failed to load alerts: {e}"}))
    
    def _save_alerts(self):
        """Save alerts to file."""
        self.alerts_file.parent.mkdir(parents=True, exist_ok=True)
        
        # Only save recent alerts (last 7 days)
        cutoff = datetime.now() - timedelta(days=7)
        recent = [a for a in self.alerts 
                  if datetime.fromisoformat(a.timestamp) > cutoff]
        
        data = {
            "alerts": [a.to_dict() for a in recent]
        }
        self.alerts_file.write_text(json.dumps(data, indent=2))
    
    def start_processing(self):
        """Start the alert processing thread."""
        if self._processing:
            return
        
        self._processing = True
        self._processor_thread = threading.Thread(
            target=self._process_queue,
            daemon=True
        )
        self._processor_thread.start()
    
    def stop_processing(self):
        """Stop the alert processing thread."""
        self._processing = False
        if self._processor_thread:
            self._processor_thread.join(timeout=2)
    
    def _process_queue(self):
        """Process alerts from the queue."""
        while self._processing:
            try:
                # Get item with timeout
                item = self.alert_queue.get(timeout=0.5)
                self._process_alert_item(item)
            except Exception:
                pass
    
    def _process_alert_item(self, item: dict):
        """Process a single alert item."""
        matches = self.keyword_matcher.match(
            text=item.get("content", ""),
            location=item.get("location", "content")
        )
        
        for match in matches:
            alert = self._create_alert_from_match(match, item)
            if alert:
                self._add_alert(alert)
    
    def process_traffic(
        self,
        domain: str = "",
        url: str = "",
        content: str = "",
        source_ip: str = "",
        source_device: str = "",
        async_process: bool = True
    ) -> List[Alert]:
        """
        Process traffic for alerts.
        
        Args:
            domain: Domain being accessed
            url: Full URL
            content: Page content
            source_ip: Source device IP
            source_device: Source device name
            async_process: Whether to process asynchronously
            
        Returns:
            List of generated alerts (empty if async)
        """
        if async_process:
            self.alert_queue.put({
                "domain": domain,
                "url": url,
                "content": content,
                "source_ip": source_ip,
                "source_device": source_device,
                "location": "content"
            })
            return []
        
        # Synchronous processing
        alerts = []
        
        # Check URL
        url_matches = self.keyword_matcher.match(url, location="url")
        for match in url_matches:
            alert = self._create_alert_from_match(match, {
                "domain": domain,
                "url": url,
                "source_ip": source_ip,
                "source_device": source_device
            })
            if alert:
                self._add_alert(alert)
                alerts.append(alert)
        
        # Check content
        content_matches = self.keyword_matcher.match(content, location="content")
        for match in content_matches:
            alert = self._create_alert_from_match(match, {
                "domain": domain,
                "url": url,
                "source_ip": source_ip,
                "source_device": source_device
            })
            if alert:
                self._add_alert(alert)
                alerts.append(alert)
        
        return alerts
    
    def _create_alert_from_match(
        self,
        match: KeywordMatch,
        context_info: dict
    ) -> Optional[Alert]:
        """Create an alert from a keyword match."""
        # Check if we should generate alert based on rules
        if not self._should_alert(match, context_info):
            return None
        
        # Generate unique ID
        alert_id = f"alert_{datetime.now().strftime('%Y%m%d_%H%M%S_%f')}"
        
        alert = Alert(
            id=alert_id,
            timestamp=datetime.now().isoformat(),
            severity=match.severity,
            category=match.keyword.category,
            title=self._generate_title(match),
            description=self._generate_description(match, context_info),
            source_ip=context_info.get("source_ip"),
            source_device=context_info.get("source_device"),
            domain=context_info.get("domain"),
            url=context_info.get("url"),
            matched_keyword=match.keyword.word,
            matched_text=match.matched_text,
            context=match.context
        )
        
        return alert
    
    def _should_alert(self, match: KeywordMatch, context_info: dict) -> bool:
        """Check if an alert should be generated based on rules."""
        # Check rate limiting
        key = f"{match.keyword.id}:{context_info.get('source_ip', '')}"
        
        now = datetime.now()
        
        # Reset hourly counter if needed
        if self._counter_reset is None or now - self._counter_reset > timedelta(hours=1):
            self._alert_counter = {}
            self._counter_reset = now
        
        # Check max alerts per hour
        count = self._alert_counter.get(key, 0)
        if count >= 100:  # Default max
            return False
        
        self._alert_counter[key] = count + 1
        
        return True
    
    def _generate_title(self, match: KeywordMatch) -> str:
        """Generate alert title."""
        severity_emoji = {
            AlertSeverity.LOW: "â„¹ï¸",
            AlertSeverity.MEDIUM: "âš ï¸",
            AlertSeverity.HIGH: "ðŸš¨",
            AlertSeverity.CRITICAL: "ðŸ”´"
        }
        
        emoji = severity_emoji.get(match.severity, "")
        category = match.keyword.category.value.replace("_", " ").title()
        
        return f"{emoji} {category} Alert: {match.keyword.word}"
    
    def _generate_description(self, match: KeywordMatch, context_info: dict) -> str:
        """Generate alert description."""
        parts = [
            f"Keyword '{match.matched_text}' detected",
            f"in {match.location}",
        ]
        
        if context_info.get("domain"):
            parts.append(f"on {context_info['domain']}")
        
        if context_info.get("source_device"):
            parts.append(f"from device {context_info['source_device']}")
        elif context_info.get("source_ip"):
            parts.append(f"from {context_info['source_ip']}")
        
        return " ".join(parts)
    
    def _add_alert(self, alert: Alert):
        """Add an alert and trigger notifications."""
        self.alerts.append(alert)
        self._save_alerts()
        
        # Output to stdout for Tauri IPC
        output_json({
            "type": "alert",
            "alert": alert.to_dict()
        })
        
        # Trigger callbacks
        for callback in self._alert_callbacks:
            try:
                callback(alert)
            except Exception:
                pass
    
    def add_callback(self, callback: Callable[[Alert], None]):
        """Add a callback for new alerts."""
        self._alert_callbacks.append(callback)
    
    def acknowledge_alert(self, alert_id: str, notes: str = "") -> bool:
        """Mark an alert as acknowledged."""
        for alert in self.alerts:
            if alert.id == alert_id:
                alert.acknowledged = True
                alert.acknowledged_at = datetime.now().isoformat()
                alert.notes = notes
                self._save_alerts()
                return True
        return False
    
    def get_alerts(
        self,
        severity: Optional[AlertSeverity] = None,
        category: Optional[AlertCategory] = None,
        acknowledged: Optional[bool] = None,
        since: Optional[datetime] = None,
        limit: int = 100
    ) -> List[Alert]:
        """
        Get alerts with optional filters.
        
        Args:
            severity: Filter by severity
            category: Filter by category
            acknowledged: Filter by acknowledgment status
            since: Only alerts after this time
            limit: Maximum number to return
            
        Returns:
            Filtered list of alerts
        """
        filtered = self.alerts
        
        if severity:
            filtered = [a for a in filtered if a.severity == severity]
        
        if category:
            filtered = [a for a in filtered if a.category == category]
        
        if acknowledged is not None:
            filtered = [a for a in filtered if a.acknowledged == acknowledged]
        
        if since:
            filtered = [
                a for a in filtered
                if datetime.fromisoformat(a.timestamp) > since
            ]
        
        # Sort by timestamp descending
        filtered.sort(key=lambda a: a.timestamp, reverse=True)
        
        return filtered[:limit]
    
    def get_unacknowledged_count(self) -> Dict[str, int]:
        """Get count of unacknowledged alerts by severity."""
        counts = {s.value: 0 for s in AlertSeverity}
        
        for alert in self.alerts:
            if not alert.acknowledged:
                counts[alert.severity.value] += 1
        
        return counts
    
    def add_rule(self, rule: AlertRule) -> bool:
        """Add an alert rule."""
        self.rules[rule.id] = rule
        self._save_config()
        return True
    
    def remove_rule(self, rule_id: str) -> bool:
        """Remove an alert rule."""
        if rule_id in self.rules:
            del self.rules[rule_id]
            self._save_config()
            return True
        return False
    
    def get_stats(self) -> dict:
        """Get alert statistics."""
        now = datetime.now()
        today = now.replace(hour=0, minute=0, second=0, microsecond=0)
        week_ago = now - timedelta(days=7)
        
        today_alerts = [
            a for a in self.alerts
            if datetime.fromisoformat(a.timestamp) > today
        ]
        
        week_alerts = [
            a for a in self.alerts
            if datetime.fromisoformat(a.timestamp) > week_ago
        ]
        
        return {
            "total_alerts": len(self.alerts),
            "today_count": len(today_alerts),
            "week_count": len(week_alerts),
            "unacknowledged": self.get_unacknowledged_count(),
            "by_category": {
                cat.value: len([a for a in self.alerts if a.category == cat])
                for cat in AlertCategory
            },
            "keywords_loaded": len(self.keyword_matcher.keywords)
        }


def output_json(data: dict) -> None:
    """Output data as JSON to stdout for Tauri IPC."""
    print(json.dumps(data, default=str), flush=True)


def main():
    """CLI entry point for alert engine."""
    import argparse
    
    parser = argparse.ArgumentParser(description="Alert engine")
    parser.add_argument("--action", choices=[
        "stats", "list", "process", "acknowledge", "unacknowledged"
    ], default="stats", help="Action to perform")
    parser.add_argument("--content", help="Content to process")
    parser.add_argument("--url", help="URL to process")
    parser.add_argument("--domain", help="Domain")
    parser.add_argument("--alert-id", help="Alert ID to acknowledge")
    parser.add_argument("--severity", help="Filter by severity")
    parser.add_argument("--category", help="Filter by category")
    parser.add_argument("--limit", type=int, default=100, help="Max results")
    
    args = parser.parse_args()
    
    engine = AlertEngine()
    
    # Load predefined keywords if none exist
    if not engine.keyword_matcher.keywords:
        engine.keyword_matcher.load_all_predefined()
    
    try:
        if args.action == "stats":
            output_json({
                "success": True,
                "stats": engine.get_stats()
            })
        
        elif args.action == "list":
            filters = {}
            if args.severity:
                filters["severity"] = AlertSeverity(args.severity)
            if args.category:
                filters["category"] = AlertCategory(args.category)
            
            alerts = engine.get_alerts(limit=args.limit, **filters)
            output_json({
                "success": True,
                "alerts": [a.to_dict() for a in alerts]
            })
        
        elif args.action == "process":
            if not args.content and not args.url:
                output_json({"success": False, "error": "No content or URL specified"})
                return
            
            alerts = engine.process_traffic(
                domain=args.domain or "",
                url=args.url or "",
                content=args.content or "",
                async_process=False
            )
            output_json({
                "success": True,
                "alerts_generated": len(alerts),
                "alerts": [a.to_dict() for a in alerts]
            })
        
        elif args.action == "acknowledge":
            if not args.alert_id:
                output_json({"success": False, "error": "No alert ID specified"})
                return
            
            success = engine.acknowledge_alert(args.alert_id)
            output_json({"success": success, "action": "acknowledged", "id": args.alert_id})
        
        elif args.action == "unacknowledged":
            output_json({
                "success": True,
                "counts": engine.get_unacknowledged_count()
            })
    
    except Exception as e:
        output_json({
            "success": False,
            "error": str(e),
            "type": type(e).__name__
        })


if __name__ == "__main__":
    main()
